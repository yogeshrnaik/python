"""
You have just been hired by a company that provides a checkout system for many online stores.
In order to make smart business decisions, the analysts at your company need detailed reports on purchases.
Unfortunately, the developer who wrote this system has moved on, and you'll need to take over the codebase.

Your task is to read and understand the existing code, and then refactor it to be as clear as possible, without breaking any tests.

The original developer left some documentation, but no one at the company has any further knowledge about how the code works.
Here's the documentation:

When a customer completes a purchase, an event is generated by the checkout system containing the following information:

Date: ISO 8601 instant; e.g. 2011-12-03T10:15:30Z
Amount: total amount of purchase in cents; e.g. 4285 (€42.85)
Payment method: Pay Now (credit card or bank transfer), Pay Later (invoice at the end of the month),
or Slice It (pay in convenient monthly installments)
Merchant ID: unique identifier of merchant; e.g. 1bb53ed1-787b-4543-9def-ea18eef7902e
Our business people want the following reports:

Number of purchases per hour, broken down by amount bracket (less than €10, €10 - €50, €50-€100, €100-€500, more than €500)
Number of purchases per hour, broken down by amount bracket and payment method
Number of purchases, broken down by amount bracket and payment method
Number of purchases per day, broken down by merchant
Number of purchases, broken down by merchant and payment method
When a purchase is completed, the checkout system publishes an event, which is picked up by the reporting system and batched.
The reporting system then invokes the aggregate function, with a list of events as its argument.
An event is a JSON object (Note that for some languages it is already parsed):

{
  "date": "2011-12-03T10:15:30Z",
  "amount": 4285,
  "paymentMethod": "SLICE_IT",
  "merchantId": "1bb53ed1-787b-4543-9def-ea18eef7902e"
}
The aggregate function returns a list of aggregates for each report that needs to be generated.

For example, given the a batch containing only the event above, the function would generate an aggregate datapoint
for the purchases by hour, amount bracket, and payment method report like this: 2011-12-03:10|10-50|SLICE_IT.
The datapoint is then combined into an aggregate object like this:

{
  "datapoint": "2011-12-03:10|10-50|SLICE_IT",
  "events": 1
}
NOTE: The tests reflect the system's public API. We do not want to break it for now, so don't rewrite the tests. If you
really want to change the shape of the data (e. g. to make the system strictly typed), then build a translation
layer, so the tests don't break.
"""

import re

AMOUNT_BRACKET_RULES = [
    lambda amount: ">500" if amount > 50000 else "",
    lambda amount: "100-500" if 10000 < amount < 50000 else "",
    lambda amount: "50-100" if 5000 < amount < 10000 else "",
    lambda amount: "10-50" if 1000 < amount < 5000 else "",
    lambda amount: "<10" if amount < 1000 else "",
]

ANY_STRING = '.+'
STARTS_WITH = '^'
DATE_SUBSTITUTION = f'{STARTS_WITH}({ANY_STRING})'
MINUTE_SECOND_PATTERN = f'{ANY_STRING}$'
HOUR_SUBSTITUTION = '(\d+)'
TIME_PATTERN = f'T{ANY_STRING}$'


def amountBracket(amount):
    return next(
        filter(
            lambda ruleResult: ruleResult,
            [ruleFunc(amount) for ruleFunc in AMOUNT_BRACKET_RULES]
        )
    )


def addAggregate(datapoint, aggregates=[]):
    if datapoint == None:
        aggregates.clear()
        return aggregates
    for i in range(0, len(aggregates)):
        if aggregates[i]["datapoint"] == datapoint:
            aggregates[i]["events"] += 1
            return

    aggregates.append({"datapoint": datapoint, "events": 1})


def aggregate(events):
    aggregates = addAggregate(None)

    for events in events:
        event_date, amount, = events["date"], events['amount']
        paymentMethod, merchantId = events['paymentMethod'], events["merchantId"]

        addAggregate(getDateWithHour(event_date) + '|' + amountBracket(amount))
        addAggregate(getDateWithHour(event_date) + '|' + amountBracket(amount) + '|' + paymentMethod)
        addAggregate(amountBracket(amount) + '|' + paymentMethod)
        addAggregate(getDateWithoutTime(event_date) + '|' + merchantId)
        addAggregate(merchantId + '|' + paymentMethod)

    return aggregates


def getDateWithoutTime(event_date):
    return re.sub(
        rf"{TIME_PATTERN}", "", event_date
    )


def getDateWithHour(event_date):
    return re.sub(
        rf"{DATE_SUBSTITUTION}T{HOUR_SUBSTITUTION}:{MINUTE_SECOND_PATTERN}", r"\1:\2", event_date
    )


import unittest

sampleEvent = {
    "date": "2011-12-03T10:15:30Z",
    "amount": 4285,
    "paymentMethod": "SLICE_IT",
    "merchantId": "1bb53ed1-787b-4543-9def-ea18eef7902e"
}


def sortKey(item):
    return item["datapoint"]


# Note: the class must be called Test
class Test(unittest.TestCase):

    def test_one_event(self):
        """The result of aggregate should contain all aggregates for one event"""
        self.assertCountEqual(
            [{"datapoint": "2011-12-03:10|10-50", "events": 1},
             {"datapoint": "2011-12-03:10|10-50|SLICE_IT", "events": 1},
             {"datapoint": "10-50|SLICE_IT", "events": 1},
             {"datapoint": "2011-12-03|1bb53ed1-787b-4543-9def-ea18eef7902e", "events": 1},
             {"datapoint": "1bb53ed1-787b-4543-9def-ea18eef7902e|SLICE_IT", "events": 1}],
            aggregate([sampleEvent]))

    def test_repeated_events(self):
        """The result of aggregate should contain one event for each aggregate"""
        self.assertCountEqual(
            [{"datapoint": "2011-12-03:10|10-50", "events": 2},
             {"datapoint": "2011-12-03:10|10-50|SLICE_IT", "events": 2},
             {"datapoint": "10-50|SLICE_IT", "events": 2},
             {"datapoint": "2011-12-03|1bb53ed1-787b-4543-9def-ea18eef7902e", "events": 2},
             {"datapoint": "1bb53ed1-787b-4543-9def-ea18eef7902e|SLICE_IT", "events": 2}],
            aggregate([sampleEvent, sampleEvent]))

    def test_multiple_events(self):
        """Multiple different events should be aggregated correctly"""
        self.assertCountEqual([{"datapoint": "10-50|PAY_NOW", "events": 1},
                               {"datapoint": "10-50|SLICE_IT", "events": 1},
                               {"datapoint": "1bb53ed1-787b-4543-9def-ea18eef7902e|PAY_LATER", "events": 1},
                               {"datapoint": "1bb53ed1-787b-4543-9def-ea18eef7902e|PAY_NOW", "events": 2},
                               {"datapoint": "1bb53ed1-787b-4543-9def-ea18eef7902e|SLICE_IT", "events": 1},
                               {"datapoint": "2011-12-03:10|10-50", "events": 1},
                               {"datapoint": "2011-12-03:10|10-50|SLICE_IT", "events": 1},
                               {"datapoint": "2011-12-03:12|10-50", "events": 1},
                               {"datapoint": "2011-12-03:12|10-50|PAY_NOW", "events": 1},
                               {"datapoint": "2011-12-03:14|<10", "events": 1},
                               {"datapoint": "2011-12-03:14|<10|PAY_NOW", "events": 1},
                               {"datapoint": "2011-12-03|1bb53ed1-787b-4543-9def-ea18eef7902e", "events": 3},
                               {"datapoint": "2011-12-04:10|>500", "events": 1},
                               {"datapoint": "2011-12-04:10|>500|PAY_LATER", "events": 1},
                               {"datapoint": "2011-12-04|1bb53ed1-787b-4543-9def-ea18eef7902e", "events": 1},
                               {"datapoint": "<10|PAY_NOW", "events": 1},
                               {"datapoint": ">500|PAY_LATER", "events": 1}],
                              aggregate([{"date": "2011-12-03T10:15:30Z",
                                          "amount": 4285,
                                          "paymentMethod": "SLICE_IT",
                                          "merchantId": "1bb53ed1-787b-4543-9def-ea18eef7902e"},
                                         {"date": "2011-12-03T12:15:30Z",
                                          "amount": 1142,
                                          "paymentMethod": "PAY_NOW",
                                          "merchantId": "1bb53ed1-787b-4543-9def-ea18eef7902e"},
                                         {"date": "2011-12-03T14:15:30Z",
                                          "amount": 185,
                                          "paymentMethod": "PAY_NOW",
                                          "merchantId": "1bb53ed1-787b-4543-9def-ea18eef7902e"},
                                         {"date": "2011-12-04T10:15:30Z",
                                          "amount": 82850,
                                          "paymentMethod": "PAY_LATER",
                                          "merchantId": "1bb53ed1-787b-4543-9def-ea18eef7902e"}]))


if __name__ == "__main__":
    unittest.main()
